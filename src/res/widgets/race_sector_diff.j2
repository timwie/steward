{% extends "base_dynamic.j2" %}

{# ============================= VARIABLES ============================= #}
{% block vars %}
    {{ super() }}

    {% set nb_sectors = top1_sector_millis | length %}

    {% set max_nb_sectors = 16 %}

    {% set sector_w = 320 / (max_nb_sectors + 2) %}
    {% set sector_h = 5 %}
    {% set sector_x_padding = 1 %}
    {% set sector_bottom_order_h = 0.5 %}

    {% set sector_label_w = sector_w - sector_x_padding*2 %}
    {% set sector_label_h = 3 %}

    {% set sector_div_w = 0.2 %}

    {% set color_bar_w = nb_sectors * sector_w %}
    {% set color_bar_h = 1 %}

    {% set frame_w = (nb_sectors + 2) * sector_w %}
    {% set frame_h = color_bar_h + sector_h*2 + sector_label_h %}
    {% set frame_x_offset = -160 + (320 - frame_w) / 2.0 %}
    
{% endblock vars %}
{# ============================= MANIALINK ============================= #}
{% block manialink %}
{{ super() }}

<frame id="total_diff" pos="0 33">
    <quad id="total_diff_bg" z-index="1"
          size="18 6" halign="center"/>

    <label id="total_diff_lbl" z-index="2"
           size="16" pos="0 -1.5" halign="center"
           textemboss="1" text_color="{{col_white}}" style="{{ font_bold_big }}"/>

    <label id="total_diff_next_sector"
           pos="0 -6.5" halign="center"  textsize="2"
           textemboss="1" text_color="{{col_white}}" textfont="RajdhaniMono"/>
</frame>

<!-- Colored bar at the top indicates whether the run is on course to become a new PB -->
<frame z-index="101">
    <quad id="color_bar"     pos="0 90"                   size="{{color_bar_w}} {{color_bar_h}}"
          bgcolor="{{col_neutral}}" z-index="1" halign="center"/>

    <quad id="color_bar_div" pos="0 {{90 - color_bar_h}}" size="{{color_bar_w}} 0.2"
          bgcolor="{{col_neutral}}" halign="center" valign="center" opacity="0.1" />
</frame>

<frame id="sectors" pos="{{frame_x_offset}} {{90 - color_bar_h}}" z-index="100">
    <!-- Dividing lines -->
    {% for i in range(end=nb_sectors-1) %}
        <quad id="sector_div_{{i}}"
              size="{{sector_div_w}} {{sector_h * 2}}" pos="{{(i+2)*sector_w}} 0" halign="center" z-index="3"
              bgcolor="{{col_neutral}}" opacity="0.1"/>
    {% endfor %}

    <!-- Labels on the left -->
    <frame pos="{{sector_w - sector_x_padding}} 0" z-index="1">
        <label size="{{sector_label_w}} {{sector_label_h}}" pos="0 {{sector_h * -0.5}}"
               text="$sPB ± Top1" style="{{ font_bold_small }}" halign="right" valign="center"
               textcolor="{{col_white}}"/>
        <label size="{{sector_label_w}} {{sector_label_h}}" pos="0 {{sector_h * -1.5}}"
               text="$sLive ± Top1" style="{{ font_bold_small }}" halign="right" valign="center"
               textcolor="{{col_white}}"/>
    </frame>

    {% for idx in range(end=nb_sectors) %}
        <frame id="sector_{{idx}}" pos="{{sector_w*(idx+1)}} 0" z-index="1">
            <!-- Cell background colors indicate whether the live sector was better or worse than the PB sector time -->
            <quad id="pb_diff_bg_{{idx}}"
                  size="{{sector_w}} {{sector_h}}" pos="0 0" opacity="0.5"/>
            <quad id="live_diff_bg_{{idx}}"
                  size="{{sector_w}} {{sector_h}}" pos="0 -{{sector_h}}" opacity="0.4"/>

            <!-- Sector numbering "S1", "S2", etc on the bottom -->
            <label id="sector_label_{{idx}}"
                   textemboss="1"
                   pos="{{sector_w/2}} {{sector_h * -2 - 1}}"
                   text="S{{idx+1}}" style="{{ font_bold_small }}" halign="center"
                   textcolor="{{col_white}}"/>

            <!-- The two diffs, one for PB vs Top1, one for Live vs Top1 -->
            <label id="pb_diff_text_{{idx}}"
                   size="{{sector_label_w}} {{sector_h}}" pos="{{sector_w/2}} {{sector_h * -0.5}}"
                   z-index="2" style="{{ font_bold_big }}" halign="center" valign="center"
                   textcolor="{{col_white}}"/>
            <label id="live_diff_text_{{idx}}"
                   size="{{sector_label_w}} {{sector_h}}" pos="{{sector_w/2}} {{sector_h * -1.5}}"
                   z-index="2" style="{{ font_bold_big }}" halign="center" valign="center"
                   textcolor="{{col_white}}"/>
        </frame>
    {% endfor %}
</frame>

{% endblock manialink %}
{# ============================= SCRIPT DECLARATIONS ============================= #}
{% block decl %}
{{ super() }}

#Const TOTAL_DIFF_VISIBLE_DURATION 2000  // how long is the cp diff visible? (ms)

#Const MIN_SECTOR_MILLIS 4000  // sectors shorter than this duration (ms) are dissolved

declare Integer   G_PbMillis;           // this player's pb time
declare Integer[] G_PbSectorMillis;     // this player's pb sector times
declare Integer[] G_PbSectorMillisAgg;  // this player's pb aggregated sector times

declare Integer   G_Top1Millis;           // top1 record time
declare Integer[] G_Top1SectorMillis;     // top1 record sector times
declare Integer[] G_Top1SectorMillisAgg;  // top1 record aggregated sector times

declare Integer   G_NbSectors;          // nb checkpoints + 1

declare Integer[] G_SectorAggregates;   // maps sector index to aggregated sector
                                        // (equal value means sectors were aggregated)

declare Boolean   G_PbIsTop1;           // True if pb == top1

declare Integer   G_RunLastCpGameTime;  // game time (millis) at time of crossing last cp

declare CMlFrame UI_Sectors;  // entire top frame

declare CMlFrame UI_TotalDiff;        // cp diff frame
declare CMlLabel UI_TotalDiffLbl;     // cp diff text
declare CMlQuad  UI_TotalDiffBg;      // cp diff bg
declare CMlLabel UI_TotalDiffSector;  // label that displays the next sector under the cp diff

declare CMlQuad  UI_ColorBar;
declare CMlQuad  UI_ColorBarDiv;

{% include "lib_time_to_text.j2" %}
{% include "lib_time_diff.j2" %}


/** Given a sector index, return the top1 sector millis for its aggregated sector. */
Integer Agg_Top1SectorMillis(Integer SectorIdx) {
    declare CurrAggMillis = 0;
    declare AggIndex = G_SectorAggregates[SectorIdx];

    for (SectorIdx, 0, G_NbSectors - 1) {
        if (G_SectorAggregates[SectorIdx] == AggIndex) {
            CurrAggMillis += G_Top1SectorMillis[SectorIdx];
        }
    }

    return CurrAggMillis;
}

/** Given a sector index, return if it is the last sector in its aggregated sector. */
Boolean Agg_IsSectorEnd(Integer SectorIdx) {
    if (SectorIdx == G_NbSectors - 1) {
        return True;
    }
    return G_SectorAggregates[SectorIdx] != G_SectorAggregates[SectorIdx + 1];
}

/** Return the number of aggregated sectors. */
Integer Agg_NbSectors() {
    declare Result = 0;

    for (SectorIdx, 0, G_NbSectors - 1) {
        if (Agg_IsSectorEnd(SectorIdx)) {
            Result += 1;
        }
    }

    return Result;
}

/** Given a sector index, return the index of its aggregated sector. */
Integer Agg_SectorIdx(Integer SectorIdx) {
    declare Result = 0;
    declare CurrAggLabel = G_SectorAggregates[SectorIdx];

    for (SectorIdx, 0, G_NbSectors - 1) {
        if (CurrAggLabel == G_SectorAggregates[SectorIdx]) {
            break;
        }
        if (Agg_IsSectorEnd(SectorIdx)) {
            Result += 1;
        }
    }

    return Result;
}

/**
 * Build aggregated sectors.
 *
 * Having a sector for each checkpoint does not work well on longer tracks.
 * The idea here is to dissolve very short sectors (caused by checkpoints
 * in quick succesion) into larger, aggregated sectors.
 *
 * Iterate through all sectors, starting with the smallest, and aggregate
 * into the smaller one of their neighboring sectors. Sectors will only
 * be dissolved if they are below a threshold duration. 
 */
Void AggregateSectors() {
    // Initialize default: no aggregated sectors.
    G_SectorAggregates.clear();
    for (i, 0, G_NbSectors - 1) {
        G_SectorAggregates.add(i);
    }

    declare Integer[] SectorMillisSorted = G_Top1SectorMillis.sort();
    declare Integer[] SectorMillisUnsorted;
    for (SectorIdx, 0, G_NbSectors - 1) {
        SectorMillisUnsorted.add(G_Top1SectorMillis[SectorIdx]);
    }

    for (i, 0, G_NbSectors - 1) {
        declare CurrMillis = SectorMillisSorted[i];
        declare CurrIndex  = SectorMillisUnsorted.keyof(CurrMillis);
        SectorMillisUnsorted[CurrIndex] = 0; // prevent duplicate millis having the same index

        declare AheadIndex  = CurrIndex + 1;
        declare BehindIndex = CurrIndex - 1;

        declare CurrAggLabel  = G_SectorAggregates[CurrIndex];
        declare CurrAggMillis = Agg_Top1SectorMillis(CurrIndex);

        if (CurrAggLabel == G_SectorAggregates[0]) {
            // First sector is generally longer because the start is slow.
            // Add an offset, so that it's more likely that the first sector
            // is dissolved.
            CurrAggMillis = MathLib::Max(0, CurrAggMillis - 2000);
        }

        if (CurrAggMillis >= MIN_SECTOR_MILLIS) {
            continue; // don't aggregate other sectors into this one
        }

        declare AheadMillis  = 0;
        declare BehindMillis = 0;
        if (CurrIndex > 0) {
            BehindMillis = Agg_Top1SectorMillis(CurrIndex - 1);
        }
        if (CurrIndex < G_NbSectors - 1) {
            AheadMillis = Agg_Top1SectorMillis(CurrIndex + 1);
        }

        declare DissolvedAggLabel = -1;
        if (AheadMillis > 0) {
            DissolvedAggLabel = G_SectorAggregates[AheadIndex];
        }
        if (BehindMillis > 0 && BehindMillis < AheadMillis) {
            DissolvedAggLabel = G_SectorAggregates[BehindIndex];
        }
        if (DissolvedAggLabel == -1) {
            continue; // cannot aggregate any sector into this one
        }

        for (i, 0, G_NbSectors - 1) {
            if (G_SectorAggregates[i] == DissolvedAggLabel) {
                G_SectorAggregates[i] = CurrAggLabel;
            }
        }
    }

    G_PbSectorMillisAgg.clear();
    G_Top1SectorMillisAgg.clear();

    declare PbCurrMillis = 0;
    declare Top1CurrMillis = 0;

    for (SectorIdx, 0, G_NbSectors - 1) {
        PbCurrMillis   += G_PbSectorMillis [SectorIdx];
        Top1CurrMillis += G_Top1SectorMillis[SectorIdx];

        if (Agg_IsSectorEnd(SectorIdx)) {
            G_PbSectorMillisAgg  .add(PbCurrMillis);
            G_Top1SectorMillisAgg.add(Top1CurrMillis);
            PbCurrMillis = 0;
            Top1CurrMillis = 0;
        }
    }
}

Void SetSectorColor(Integer SectorIdx, Text HexColor) {
    {% raw %}
    declare UI_PbDiffBg   = (Page.GetFirstChild("""pb_diff_bg_{{{SectorIdx}}}""") as CMlQuad);
    declare UI_LiveDiffBg = (Page.GetFirstChild("""live_diff_bg_{{{SectorIdx}}}""") as CMlQuad);
    {% endraw %}

    declare RgbColor = ColorLib::HexToRgb(HexColor);
    UI_PbDiffBg.BgColor   = RgbColor;
    UI_LiveDiffBg.BgColor = RgbColor;

    if (HexColor == "{{col_neutral}}") {
        UI_PbDiffBg.Opacity   = 0.5;
        UI_LiveDiffBg.Opacity = 0.4;
    } else {
        UI_PbDiffBg.Opacity   = 0.9;
        UI_LiveDiffBg.Opacity = 0.8;
    }
}

/** Clear the row for live diffs, reset the colors, update the PB diff. */
Void OnReset() {
    // Recalculate PB diff in case a new PB or Top1 was set.
    for (SectorIdx, 0, G_NbSectors - 1)
    {
        {% raw %}
        declare UI_PbDiffText = (Page.GetFirstChild("""pb_diff_text_{{{SectorIdx}}}""") as CMlLabel);
        {% endraw %}

        if (G_PbIsTop1) {
            UI_PbDiffText.Value = "";
        } else {
            UI_PbDiffText.Value = "$s" ^ Diff(G_Top1SectorMillisAgg[SectorIdx], G_PbSectorMillisAgg[SectorIdx]);
        }
    }

    // UI Update #1: clear live diffs.
    for (SectorIdx, 0, G_NbSectors - 1)
    {
        {% raw %}
        declare UI_LiveDiffText = (Page.GetFirstChild("""live_diff_text_{{{SectorIdx}}}""") as CMlLabel);
        {% endraw %}

        SetSectorColor(SectorIdx, "{{col_neutral}}");
        UI_LiveDiffText.Value = "";
    }

    // UI Update #2: reset the top bar color.
    UI_ColorBar.BgColor = ColorLib::HexToRgb("{{col_neutral}}");

    // UI Update #3 (if new aggregates): filter visible sectors
    declare MaxSectorVisible = Agg_NbSectors();
    for (SectorIdx, 0, G_NbSectors - 1) {
        {% raw %}
        declare UI_Sector    = (Page.GetFirstChild("""sector_{{{SectorIdx}}}""") as CMlFrame);
        declare UI_SectorDiv = (Page.GetFirstChild("""sector_div_{{{SectorIdx}}}""") as CMlFrame);
        {% endraw %}

        UI_Sector.Visible = SectorIdx + 1 <= MaxSectorVisible;

        if (SectorIdx < G_NbSectors - 1) {
            UI_SectorDiv.Visible = SectorIdx + 1 <= MaxSectorVisible;
        }
    }

    // UI Update #4 (if new aggregates): set color bar length
    declare ColorBarWidth = MaxSectorVisible * 1. * {{sector_w}};
    UI_ColorBar.Size = <ColorBarWidth, UI_ColorBar.Size.Y>;
    UI_ColorBarDiv.Size = <ColorBarWidth, UI_ColorBarDiv.Size.Y>;

    // UI Update #5 (if new aggregates): re-center sectors
    declare TotalWidth = (MaxSectorVisible + 2) * {{sector_w}} * 1.;
    declare Offset = -160. + (320. - TotalWidth) / 2.0;
    UI_Sectors.RelativePosition_V3 = <Offset, UI_Sectors.RelativePosition_V3.Y>;
}

/** Clear live sector data, and reset the UI. */
Void Reset(CTmRaceClientEvent Event) {
    declare Integer[] P_RunSectorMillis for Event.Player;
    declare Integer   P_RunLastCpMillis for Event.Player;

    P_RunSectorMillis.clear();
    P_RunLastCpMillis = 0;

    if (Event.Player == InputPlayer) {
        OnReset();
    }
}

Void OnNewTop1() {
    AggregateSectors();
}

/**
 * Update sector data for this player.
 * Previous data will be cleared if this is the first sector.
 *
 * If this is the input player, add the visual sector diff, and update colors.
 */
Void OnCheckpoint(CTmRaceClientEvent Event) {
    declare Integer[] P_RunSectorMillis for Event.Player;
    declare Integer   P_RunLastCpMillis for Event.Player;

    G_RunLastCpGameTime = GameTime;

    declare SectorIdx = Event.CheckpointInRace;
    if (SectorIdx == 0) {
        Reset(Event);
    } else if (SectorIdx > P_RunSectorMillis.count) {
        // If this script is added during a player's run, we might have missed some
        // sector data already. Ignore this run to prevent inconsistencies.
        return;
    }

    declare SectorMillis_Live = Event.RaceTime - P_RunLastCpMillis;

    P_RunLastCpMillis = Event.RaceTime;
    P_RunSectorMillis.add(SectorMillis_Live);

    if (Event.Player != InputPlayer) {
        return;
    }

    declare TotalMillis_Live = Event.RaceTime;
    declare TotalMillis_Pb   = 0;

    for (i, 0, SectorIdx) {
        TotalMillis_Pb += G_PbSectorMillis[i];
    }


    // Show CP diff in center of screen.
    UI_TotalDiff.Visible = !Event.IsEndRace;
    if (!Event.IsEndRace) {
        UI_TotalDiffLbl.Value = Diff(TotalMillis_Pb, TotalMillis_Live);
    }

    if (TotalMillis_Live >= TotalMillis_Pb) {
        UI_TotalDiffBg.BgColor = ColorLib::HexToRgb("{{col_fail}}");
    } else {
        UI_TotalDiffBg.BgColor = ColorLib::HexToRgb("{{col_success}}");
    }

    UI_TotalDiffSector.Value = "";

    // If the player finished an aggregated sector, update the UI.
    if (!Agg_IsSectorEnd(SectorIdx)) {
        return;
    }

    declare SectorIdxAggr = G_SectorAggregates[SectorIdx];
    declare FixedSectorIdx = Agg_SectorIdx(SectorIdx);

    UI_TotalDiffSector.Value = "Sector "^(FixedSectorIdx + 2); // the sector that is now entered

    {% raw %}
    declare UI_LiveDiffText = (Page.GetFirstChild("""live_diff_text_{{{FixedSectorIdx}}}""") as CMlLabel);
    {% endraw %}

    declare FixedSectorMillis_Live = 0;
    declare SectorMillis_Pb   = G_PbSectorMillisAgg[FixedSectorIdx];
    declare SectorMillis_Top1 = G_PbSectorMillisAgg[FixedSectorIdx];

    for (i, 0, SectorIdx) {
        if (G_SectorAggregates[i] == G_SectorAggregates[SectorIdx]) {
            FixedSectorMillis_Live += P_RunSectorMillis[i];
        }
    }

    if (FixedSectorMillis_Live >= SectorMillis_Pb) {
        SetSectorColor(FixedSectorIdx, "{{col_fail}}");
    } else {
        SetSectorColor(FixedSectorIdx, "{{col_success}}");
    }

    if (TotalMillis_Live >= TotalMillis_Pb) {
        UI_ColorBar.BgColor = ColorLib::HexToRgb("{{col_fail}}");
    } else {
        UI_ColorBar.BgColor = ColorLib::HexToRgb("{{col_success}}");
    }

    // TODO rename, confusing with cp
    UI_LiveDiffText.Value = "$s" ^ Diff(SectorMillis_Top1, FixedSectorMillis_Live);
}

Void OnFinish(CTmRaceClientEvent Event) {
    declare Integer[] P_RunSectorMillis for Event.Player;

    // Update PB if this player's run was better
    if (Event.Player == InputPlayer && Event.RaceTime < G_PbMillis) {
        G_PbMillis = Event.RaceTime;
        G_PbSectorMillis = P_RunSectorMillis;
    }

    // Update Top1 record if any player's run was better
    if (Event.RaceTime < G_Top1Millis) {
        G_PbIsTop1 = Event.Player == InputPlayer;
        G_Top1Millis = Event.RaceTime;
        G_Top1SectorMillis = P_RunSectorMillis;
        OnNewTop1();
    }
}

/**
 * Update the live sector data for any player,
 * and update PB & Top1 record whenever a better time was set.
 */
Void OnCheckpointOrFinish(CTmRaceClientEvent Event) {
    if (Event.RaceTime <= 0) {
        Reset();
        return; // invalid times are set to zero
    }

    OnCheckpoint(Event);

    if (Event.IsEndRace) {
        OnFinish(Event);
    }
}

{% endblock decl %}
{# ============================= SCRIPT MAIN ============================= #}
{% block main %}

UI_ColorBar    = (Page.GetFirstChild("color_bar") as CMlQuad);
UI_ColorBarDiv = (Page.GetFirstChild("color_bar_div") as CMlQuad);
UI_Sectors     = (Page.GetFirstChild("sectors") as CMlFrame);
UI_TotalDiff       = (Page.GetFirstChild("total_diff") as CMlFrame);
UI_TotalDiffLbl    = (Page.GetFirstChild("total_diff_lbl") as CMlLabel);
UI_TotalDiffBg     = (Page.GetFirstChild("total_diff_bg") as CMlQuad);
UI_TotalDiffSector = (Page.GetFirstChild("total_diff_next_sector") as CMlLabel);

G_PbMillis         = {{ pb_millis }};
G_PbSectorMillis   = {{ pb_sector_millis }};
G_Top1Millis       = {{ top1_millis }};
G_Top1SectorMillis = {{ top1_sector_millis }};
G_NbSectors        = {{ nb_sectors }};

G_PbIsTop1 = True;
for (SectorIdx, 0, G_NbSectors - 1) {
    assert(G_PbSectorMillis[SectorIdx] >= G_Top1SectorMillis[SectorIdx]);
    if (G_PbSectorMillis[SectorIdx] != G_Top1SectorMillis[SectorIdx]) {
        G_PbIsTop1 = False;
        break;
    }
}

OnNewTop1();
OnReset();

{% endblock main %}
{# ============================= SCRIPT EVENTS ============================= #}
{% block race_events %}

switch (Event.Type) {
    case CTmRaceClientEvent::EType::WayPoint: {
        OnCheckpointOrFinish(Event);
    }
    case CTmRaceClientEvent::EType::Respawn: {
        UI_TotalDiff.Visible = False;
    }
}

{% endblock race_events %}
{# ============================= LOOP ============================= #}
{% block loop %}

UI_TotalDiff.Visible = GameTime < G_RunLastCpGameTime + TOTAL_DIFF_VISIBLE_DURATION;

{% endblock loop %}
